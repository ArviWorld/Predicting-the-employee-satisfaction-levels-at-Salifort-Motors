# Apply the model probabilitites to the entropy function
entropy_rf <- compute_entropy(as.matrix(prob_rf))
entropy_xgb <- compute_entropy(as.matrix(prob_xgb))
# Setting up the plot
# Create templates for the model
entropy_raster_rf <- raster::raster(predictors_stack)
entropy_raster_xgb <- raster::raster(predictors_stack)
# Setting all values to NA
values(entropy_raster_rf) <- NA
values(entropy_raster_xgb) <- NA
# Inserting the entropy values at valid locations
values(entropy_raster_rf)[valid_idx] <- entropy_rf
values(entropy_raster_xgb)[valid_idx] <- entropy_xgb
# Convert raster to data frame for ggplot
# Random Forest
df_entropy_rf <- as.data.frame(entropy_raster_rf,
xy = TRUE, na.rm = TRUE)
colnames(df_entropy_rf)[3] <- "entropy"
# XGBoost
df_entropy_xgb <- as.data.frame(entropy_raster_xgb,
xy = TRUE, na.rm = TRUE)
colnames(df_entropy_xgb)[3] <- "entropy"
# Create the ggplot for Random Forest entropy
p_rf <- ggplot(df_entropy_rf, aes(x = x, y = y, fill = entropy)) +
geom_raster() +
scale_fill_viridis(option = "viridis") +
coord_equal() +
labs(title = "Entropy - Random Forest", fill = "Entropy") +
theme_minimal()
# Create the ggplot for XGBoost entropy
p_xgb <- ggplot(df_entropy_xgb, aes(x = x, y = y, fill = entropy)) +
geom_raster() +
scale_fill_viridis(option = "viridis") +
coord_equal() +
labs(title = "Entropy - XGBoost", fill = "Entropy") +
theme_minimal()
# Plot the entropy maps
p_rf
p_xgb
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
roc_rf <- model_performance(explainer_rf, type = "roc")
roc_xgb <- model_performance(explainer_xgb, type = "roc")
# Extract ROC data using the '$roc_curve' slot
roc_rf <- perf_rf$roc_curve
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
perf_rf <- model_performance(explainer_rf, type = "roc")
perf_xgb <- model_performance(explainer_xgb, type = "roc")
# Extract ROC data using the '$roc_curve' slot
roc_rf <- perf_rf$roc_curve
roc_rf$model <- "Random Forest"
roc_xgb <- perf_xgb$roc_curve
roc_xgb$model <- "XGBoost"
# Combine ROC data
roc_all <- rbind(roc_rf, roc_xgb)
# Plot ROC curves
ggplot(roc_all, aes(x = false.positive.rate, y = true.positive.rate, color = model)) +
geom_line(size = 1.2) +
geom_abline(linetype = "dashed", color = "gray") +
labs(
title = "ROC Curve Comparison",
x = "False Positive Rate",
y = "True Positive Rate"
) +
theme_minimal() +
theme(legend.position = "bottom", text = element_text(size = 14))
rlang::last_trace()
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
perf_rf <- model_performance(explainer_rf, type = "roc")
perf_xgb <- model_performance(explainer_xgb, type = "roc")
# Extract ROC data using the '$roc_curve' slot
roc_rf <- perf_rf$roc_curve
roc_rf$model <- "Random Forest"
roc_xgb <- perf_xgb$roc_curve
roc_xgb$model <- "XGBoost"
# Combine ROC data
roc_all <- rbind(roc_rf, roc_xgb)
roc_all
# Plot ROC curves
ggplot(roc_all, aes(x = false.positive.rate, y = true.positive.rate, color = model)) +
geom_line(size = 1.2) +
geom_abline(linetype = "dashed", color = "gray") +
labs(
title = "ROC Curve Comparison",
x = "False Positive Rate",
y = "True Positive Rate"
) +
theme_minimal() +
theme(legend.position = "bottom", text = element_text(size = 14))
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
perf_rf <- model_performance(explainer_rf, type = "roc")
perf_xgb <- model_performance(explainer_xgb, type = "roc")
# Extract ROC data using the '$roc_curve' slot
roc_rf <- perf_rf$roc_curve
roc_rf$model <- "Random Forest"
roc_xgb <- perf_xgb$roc_curve
roc_xgb$model <- "XGBoost"
# Combine ROC data
roc_all <- rbind(roc_rf, roc_xgb)
str(roc_all)
# Plot ROC curves
ggplot(roc_all, aes(x = false.positive.rate, y = true.positive.rate, color = model)) +
geom_line(size = 1.2) +
geom_abline(linetype = "dashed", color = "gray") +
labs(
title = "ROC Curve Comparison",
x = "False Positive Rate",
y = "True Positive Rate"
) +
theme_minimal() +
theme(legend.position = "bottom", text = element_text(size = 14))
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
perf_rf <- model_performance(explainer_rf, type = "roc")
perf_xgb <- model_performance(explainer_xgb, type = "roc")
# Extract ROC data using the '$roc_curve' slot
roc_rf <- perf_rf$roc_curve
roc_rf$model <- "Random Forest"
roc_xgb <- perf_xgb$roc_curve
roc_xgb$model <- "XGBoost"
plot(roc_rf)
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
perf_rf <- model_performance(explainer_rf, type = "roc")
perf_xgb <- model_performance(explainer_xgb, type = "roc")
# Extract curves
roc_curve_rf <- as.data.frame(roc_rf$curve)
roc_curve_rf$model <- "Random Forest"
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
perf_rf <- model_performance(explainer_rf, type = "roc")
perf_xgb <- model_performance(explainer_xgb, type = "roc")
# Extract curves
roc_curve_rf <- as.data.frame(roc_rf$curve)
roc_curve_xgb <- as.data.frame(roc_xgb$curve)
# Combine
roc_all <- rbind(roc_curve_rf, roc_curve_xgb)
# Plot ROC curves
ggplot(roc_all, aes(x = false.positive.rate, y = true.positive.rate, color = model)) +
geom_line(size = 1.2) +
geom_abline(linetype = "dashed", color = "gray") +
labs(
title = "ROC Curve Comparison",
x = "False Positive Rate",
y = "True Positive Rate"
) +
theme_minimal() +
theme(legend.position = "bottom", text = element_text(size = 14))
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
perf_rf <- model_performance(explainer_rf, type = "roc")
perf_xgb <- model_performance(explainer_xgb, type = "roc")
str(roc_rf$curve)
str(roc_xgb$curve)
# Extract curves
roc_curve_rf <- as.data.frame(roc_rf$curve)
roc_curve_xgb <- as.data.frame(roc_xgb$curve)
# Combine
roc_all <- rbind(roc_curve_rf, roc_curve_xgb)
# Plot ROC curves
ggplot(roc_all, aes(x = false.positive.rate, y = true.positive.rate, color = model)) +
geom_line(size = 1.2) +
geom_abline(linetype = "dashed", color = "gray") +
labs(
title = "ROC Curve Comparison",
x = "False Positive Rate",
y = "True Positive Rate"
) +
theme_minimal() +
theme(legend.position = "bottom", text = element_text(size = 14))
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
mp_rf <- model_performance(explainer_rf, type = "roc")
mp_xgb <- model_performance(explainer_xgb, type = "roc")
head(mp_rf$curve)
# DALEX - Predict Diagnostics
# Take 5 random observations from the test set
set.seed(123)
new_obs <- testDat[1, predictors]
# Compute diagnostocs for each model
diag_rf <- predict_diagnostics(explainer_rf,
new_observation =  new_obs, N=NULL)
diag_xgb <- predict_diagnostics(explainer_xgb,
new_observation = new_obs, N=NULL)
# Plotting uncertainty histograms
hist_rf <- rbind(diag_rf$histogram_neighbors, diag_rf$histogram_all)
hist_rf$model <- "Random Forest"
hist_xgb <- rbind(diag_xgb$histogram_neighbors, diag_xgb$histogram_all)
hist_xgb$model <- "XGBoost"
# Combine all
combined_hist <- rbind(hist_rf, hist_xgb)
# Plotting the histogram
ggplot(combined_hist, aes(x = Var1, y = Freq, fill = direction)) +
geom_bar(stat = "identity", position = "dodge") +
facet_wrap(~model, scales = "free_y") +
scale_fill_manual(values = c("neighbors" = "steelblue", "all" = "tomato")) +
theme_minimal() +
labs(title = "Similarity to Training Data",
x = "Distance Bin",
y = "Frequency",
fill = "Compared To") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, , size = 5))
# DALEX - Model Performance
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Residual performance (classification)
mp_rf <- model_performance(explainer_rf, type = "classification")
mp_xgb <- model_performance(explainer_xgb, type = "classification")
head(mp_rf$curve)
# DALEX - Predict Diagnostics
# Take 5 random observations from the test set
set.seed(123)
new_obs <- testDat[1, predictors]
# Compute diagnostocs for each model
diag_rf <- predict_diagnostics(explainer_rf,
new_observation =  new_obs, N=NULL)
diag_xgb <- predict_diagnostics(explainer_xgb,
new_observation = new_obs, N=NULL)
# Plotting uncertainty histograms
hist_rf <- rbind(diag_rf$histogram_neighbors, diag_rf$histogram_all)
hist_rf$model <- "Random Forest"
hist_xgb <- rbind(diag_xgb$histogram_neighbors, diag_xgb$histogram_all)
hist_xgb$model <- "XGBoost"
# Combine all
combined_hist <- rbind(hist_rf, hist_xgb)
# Plotting the histogram
ggplot(combined_hist, aes(x = Var1, y = Freq, fill = direction)) +
geom_bar(stat = "identity", position = "dodge") +
facet_wrap(~model, scales = "free_y") +
scale_fill_manual(values = c("neighbors" = "steelblue", "all" = "tomato")) +
theme_minimal() +
labs(title = "Similarity to Training Data",
x = "Distance Bin",
y = "Frequency",
fill = "Compared To") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, , size = 5))
# DALEX - Prediction Diagnostics
# Define a safe predict function
predict_class <- function(m, d) predict(m, d, type = "raw")
# Create explainers for each model using DALEX
explainer_rf <- DALEX::explain(model_rf,
data = testDat[, predictors],
y = testDat$Class,
label = "Random Forest")
explainer_xgb <- DALEX::explain(model_xgb,
data = testDat[, predictors],
y = testDat$Class,
label = "XGBoost")
# Take 5 random observations from the test set
set.seed(123)
new_obs <- testDat[1, predictors]
# Compute diagnostocs for each model
diag_rf <- predict_diagnostics(explainer_rf,
new_observation =  new_obs, N=NULL)
diag_xgb <- predict_diagnostics(explainer_xgb,
new_observation = new_obs, N=NULL)
# Plotting uncertainty histograms
hist_rf <- rbind(diag_rf$histogram_neighbors, diag_rf$histogram_all)
hist_rf$model <- "Random Forest"
hist_xgb <- rbind(diag_xgb$histogram_neighbors, diag_xgb$histogram_all)
hist_xgb$model <- "XGBoost"
# Combine all
combined_hist <- rbind(hist_rf, hist_xgb)
# Plotting the histogram
ggplot(combined_hist, aes(x = Var1, y = Freq, fill = direction)) +
geom_bar(stat = "identity", position = "dodge") +
facet_wrap(~model, scales = "free_y") +
scale_fill_manual(values = c("neighbors" = "steelblue", "all" = "tomato")) +
theme_minimal() +
labs(title = "Similarity to Training Data",
x = "Distance Bin",
y = "Frequency",
fill = "Compared To") +
theme(axis.text.x = element_text(angle = 45, hjust = 1, , size = 5))
# Preparing the data
# Convert the raster predictors to dataframe
pred_data <- as.data.frame(predictors_stack, na.rm = TRUE)
valid_idx <- which(complete.cases(pred_data))
pred_data_valid <- pred_data[valid_idx, ]
# Predicting the model probabilities
prob_rf <- predict(model_rf, pred_data, type='prob')
prob_xgb <- predict(model_xgb, pred_data, type='prob')
# Computing the entropy for the models
compute_entropy <- function (p) {
epsilon <- 1e-12 # Avoid log 0
p <- pmax(pmin(p, 1 - epsilon), epsilon)  # Clip values between epsilon and 1 - epsilon
-rowSums(p * log2(p))
}
# Apply the model probabilitites to the entropy function
entropy_rf <- compute_entropy(as.matrix(prob_rf))
entropy_xgb <- compute_entropy(as.matrix(prob_xgb))
# Setting up the plot
# Create templates for the model
entropy_raster_rf <- raster::raster(predictors_stack)
entropy_raster_xgb <- raster::raster(predictors_stack)
# Setting all values to NA
values(entropy_raster_rf) <- NA
values(entropy_raster_xgb) <- NA
# Inserting the entropy values at valid locations
values(entropy_raster_rf)[valid_idx] <- entropy_rf
values(entropy_raster_xgb)[valid_idx] <- entropy_xgb
# Convert raster to data frame for ggplot
# Random Forest
df_entropy_rf <- as.data.frame(entropy_raster_rf,
xy = TRUE, na.rm = TRUE)
colnames(df_entropy_rf)[3] <- "entropy"
# XGBoost
df_entropy_xgb <- as.data.frame(entropy_raster_xgb,
xy = TRUE, na.rm = TRUE)
colnames(df_entropy_xgb)[3] <- "entropy"
# Create the ggplot for Random Forest entropy
p_rf <- ggplot(df_entropy_rf, aes(x = x, y = y, fill = entropy)) +
geom_raster() +
scale_fill_viridis(option = "viridis") +
coord_equal() +
labs(title = "Entropy - Random Forest", fill = "Entropy") +
theme_minimal()
# Create the ggplot for XGBoost entropy
p_xgb <- ggplot(df_entropy_xgb, aes(x = x, y = y, fill = entropy)) +
geom_raster() +
scale_fill_viridis(option = "viridis") +
coord_equal() +
labs(title = "Entropy - XGBoost", fill = "Entropy") +
theme_minimal()
# Plot the entropy maps
par(mfrow(1,2))
# Preparing the data
# Convert the raster predictors to dataframe
pred_data <- as.data.frame(predictors_stack, na.rm = TRUE)
valid_idx <- which(complete.cases(pred_data))
pred_data_valid <- pred_data[valid_idx, ]
# Predicting the model probabilities
prob_rf <- predict(model_rf, pred_data, type='prob')
prob_xgb <- predict(model_xgb, pred_data, type='prob')
# Computing the entropy for the models
compute_entropy <- function (p) {
epsilon <- 1e-12 # Avoid log 0
p <- pmax(pmin(p, 1 - epsilon), epsilon)  # Clip values between epsilon and 1 - epsilon
-rowSums(p * log2(p))
}
# Apply the model probabilitites to the entropy function
entropy_rf <- compute_entropy(as.matrix(prob_rf))
entropy_xgb <- compute_entropy(as.matrix(prob_xgb))
# Setting up the plot
# Create templates for the model
entropy_raster_rf <- raster::raster(predictors_stack)
entropy_raster_xgb <- raster::raster(predictors_stack)
# Setting all values to NA
values(entropy_raster_rf) <- NA
values(entropy_raster_xgb) <- NA
# Inserting the entropy values at valid locations
values(entropy_raster_rf)[valid_idx] <- entropy_rf
values(entropy_raster_xgb)[valid_idx] <- entropy_xgb
# Convert raster to data frame for ggplot
# Random Forest
df_entropy_rf <- as.data.frame(entropy_raster_rf,
xy = TRUE, na.rm = TRUE)
colnames(df_entropy_rf)[3] <- "entropy"
# XGBoost
df_entropy_xgb <- as.data.frame(entropy_raster_xgb,
xy = TRUE, na.rm = TRUE)
colnames(df_entropy_xgb)[3] <- "entropy"
# Create the ggplot for Random Forest entropy
p_rf <- ggplot(df_entropy_rf, aes(x = x, y = y, fill = entropy)) +
geom_raster() +
scale_fill_viridis(option = "viridis") +
coord_equal() +
labs(title = "Entropy - Random Forest", fill = "Entropy") +
theme_minimal()
# Create the ggplot for XGBoost entropy
p_xgb <- ggplot(df_entropy_xgb, aes(x = x, y = y, fill = entropy)) +
geom_raster() +
scale_fill_viridis(option = "viridis") +
coord_equal() +
labs(title = "Entropy - XGBoost", fill = "Entropy") +
theme_minimal()
# Plot the entropy maps
par(mfrow=c(1,2))
p_rf
p_xgb
par(mfrow=c(1,1))
library(tinytex)
The HR department at Salifort Motors wants to take some initiatives to improve employee satisfaction levels at the company. They collected data from employees, but now they don’t know what to do with it. They refer to the data analytics professional and ask them to provide data-driven suggestions based on your understanding of the data. They have the following question: what’s likely to make the employee leave the company?
reticulate::repl_python()
reticulate::repl_python()
library(reticulate)
reticulate::repl_python()
library(reticulate)
library(reticulate)
reticulate::repl_python()
gc()
reticulate::repl_python()
library(reticulate)
use_python("C:\\Users\\Administrator\\miniconda3\\python.exe")         # For base Python
library(reticulate)
use_condaenv("r-reticulate", required = TRUE)  # Or replace with your conda env
library(reticulate)
reticulate::repl_python()
gc()
library(reticulate)
reticulate::repl_python()
